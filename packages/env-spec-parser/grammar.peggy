// @env-spec grammar
// ==========================

// injected into the top of the generated file, so is available in all rules
{{
// ðŸš¨ ðŸš¨ ðŸš¨ THIS FILE IS AUTOGENERATED - DO NOT EDIT DIRECTLY ðŸš¨ ðŸš¨ ðŸš¨
import {
  ParsedEnvSpecFile, ParsedEnvSpecConfigItem, ParsedEnvSpecCommentBlock,
  ParsedEnvSpecDivider, ParsedEnvSpecDecoratorComment, ParsedEnvSpecComment,
  ParsedEnvSpecDecorator, ParsedEnvSpecStaticValue, ParsedEnvSpecFunctionCall,
  ParsedEnvSpecBlankLine, ParsedEnvSpecFunctionArgs, ParsedEnvSpecKeyValuePair,
} from './classes';
}}

EnvSpecFile =
  contents:(
    ConfigItem
    / Divider
    / CommentBlock
    / "\n" { return new ParsedEnvSpecBlankLine({ _location: location() }); }
  )* {
    return new ParsedEnvSpecFile(contents)
  }

ConfigItem =
  preComments:(@(DecoratorComment / Comment) "\n")*
  key:ConfigItemKey "=" value:ConfigItemValue?
  _
  postComment:(@(DecoratorComment / Comment))?
  _n {
    return new ParsedEnvSpecConfigItem({
      key,
      preComments,
      postComment,
      value,
      _location: location(),
    });
  }

ConfigItemKey = 
  $([a-zA-Z_] [a-zA-Z0-9_]*)

ConfigItemValue = FunctionCall / multiLineString / quotedString / unquotedString



CommentBlock =
  // not sure if we want to treat these as decorators if within comment block?
  comments:(@(DecoratorComment / Comment) "\n")+
  end:(Divider / _n)
  {
    return new ParsedEnvSpecCommentBlock({
      comments,
      divider: end instanceof ParsedEnvSpecDivider ? end : undefined,
      _location: location(),
    })
  }

Comment = 
  !(Divider)
  "#" _ contents:$([^\n]*) {
    return new ParsedEnvSpecComment({
      contents,
      _location: location(),
    })
  }


DecoratorComment = "#" _ first:Decorator rest:(_ @(Decorator))* _ postComment:Comment? {
  return new ParsedEnvSpecDecoratorComment({
    decorators: [first, ...rest],
    postComment,
    _location: location(),
  })
}

Decorator = 
  "@" name:DecoratorName
  valueOrFnArgs:( 
    "()" { return new ParsedEnvSpecFunctionArgs({ values: [] })}
    / ("(" @FunctionArgs? ")")
    / ("=" @(DecoratorValue))
  )?
  {
  return new ParsedEnvSpecDecorator({
    name,
    valueOrFnArgs,
    _location: location(),
  })
}
DecoratorName = $([a-zA-Z] [a-zA-Z0-9_]*)
DecoratorValue = FunctionCall / quotedString / unquotedString


FunctionCall =
  name:FunctionName "(" args:FunctionArgs? ")" {
    return new ParsedEnvSpecFunctionCall({
      name,
      args: args || new ParsedEnvSpecFunctionArgs({ values: [] }),
      _location: location(),
    });
  }
FunctionName = $([a-zA-Z] [a-zA-Z0-9_]*)
FunctionArgs =
  values:(
    // combine key=val pairs into a single object
    (key:FunctionArgKeyName "=" val:FunctionArgValue { return new ParsedEnvSpecKeyValuePair({ key, val })})|1.., _ "," _|
    / FunctionArgValue|1.., _ "," _|
  ) {
    return new ParsedEnvSpecFunctionArgs({
      values,
      _location: location(),
    });
  }
FunctionArgKeyName = $([a-zA-Z] [a-zA-Z0-9_]*)
FunctionArgValue =
  quotedString
  / $([^ \n,)]+) { // these unquoted are slightly different - can contain "#", cannot contain ")" or ","
    return new ParsedEnvSpecStaticValue({ rawValue: text(), _location: location() })
  }

Divider = 
  "#" " "? contents:$([-=]|3..| [^\n]*) _n {
    return new ParsedEnvSpecDivider({
      contents,
      _location: location(),
    });
  }


// basic values

// cannot use separate rules for int/decimal/string because they match early and then get confused
unquotedString =
  $([^ #\n]+) {
    return new ParsedEnvSpecStaticValue({ rawValue: text(), _location: location() })
  }

quotedString =
  DQuotedString / SQuotedString / BQuotedString
DQuotedString = // double quote wrapped string
  quote:["] ("\\\"" / [^"\n])* ["] {
    return new ParsedEnvSpecStaticValue({ quote, rawValue: text(), _location: location() })
  }
SQuotedString = // single quote wrapped string
  quote:['] ("\\'" / [^'\n])  * ['] {
    return new ParsedEnvSpecStaticValue({ quote, rawValue: text(), _location: location() })
  }
BQuotedString = // backtick quote wrapped string
  quote:[`] ("\\`" / [^`\n])* [`] {
    return new ParsedEnvSpecStaticValue({ quote, rawValue: text(), _location: location() })
  }

multiLineString =
  singleDQuotedMultiLineString / tripleDQuotedMultiLineString / tripleBQuotedMultiLineString

singleDQuotedMultiLineString = // double quote (single) wrapped multi-line string
  quote:"\""
  (("\\\"" / [^"\n])* "\n")+
  ("\\\"" / [^"\n])*
  "\"" {
    return new ParsedEnvSpecStaticValue({ quote, isMultiLine: true, rawValue: text(), _location: location() })
  }

tripleDQuotedMultiLineString = // triple double quote wrapped multi-line string
  quote:"\"\"\""
  (("\\\"\"\"" / (!"\"\"\"" [^\n]))* "\n")+  // handle escapes - `\"""` should not trigger the end
  ( "\\\"\"\"" / (!"\"\"\"" [^\n]))*
  "\"\"\"" {
    return new ParsedEnvSpecStaticValue({ quote, isMultiLine: true, rawValue: text(), _location: location() })
  }

tripleBQuotedMultiLineString = // triple double quote wrapped multi-line string
  quote:"```"
  (("\\```" / (!"```" [^\n]))* "\n")+ // see above for explanation
  ( "\\```" / (!"```" [^\n]))*
  "```" {
    return new ParsedEnvSpecStaticValue({ quote, isMultiLine: true, rawValue: text(), _location: location() })
  }

_n = "\n" / !.
_ = [ \t]*
__ = [ \t]+

