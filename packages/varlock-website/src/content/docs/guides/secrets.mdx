---
title: Secrets management
description: Best practices for managing secrets and sensitive environment variables with varlock
---

`varlock` uses the term _sensitive_ to describe any value that should not be exposed to the outside world. This includes secret api keys, passwords, and other generally sensitive information. Instead of relying on prefixes (e.g., `NEXT_PUBLIC_`) to know which items may be "public", varlock relies on `@decorators` to mark sensitive items explicitly.

{/* For local development, `varlock` allows you to encrypt sensitive values in your `.env.*` files using `varlock encrypt` and then decrypt them using `varlock load` or `varlock run`.

This (currently) works exclusively for local development since it relies on encryption keys stored on your system. */}

:::tip[Coming soon]
We'll be adding support for our own trustless, cloud-based secret storage in the very near future. 
:::

{/* ## Encryption via `varlock`

1. [Install](/getting-started/installation) `varlock` including the desktop app
2. Add sensitive values to your `.env.*` file(s)
3. Encrypt them using `varlock encrypt`
4. Decrypt them using `varlock load` or `varlock run` */}

## Marking `@sensitive` items
Whether each item is sensitive or not is controlled by the [`@defaultSensitive`](/reference/root-decorators/#defaultsensitive) root decorator and the [`@sensitive`](/reference/item-decorators/#sensitive) item decorator. Whether you want to default to sensitive or not, or infer based on key names is up to you. For example:

```diff lang="env-spec" title=".env.schema"
# @defaultSensitive=false
# ---
# not sensitive by default (because of the root decorator)
NON_SECRET_FOO=
# @sensitive # explicitly marking this item as sensitive
SECRET_FOO=
```

## Loading secrets from external sources

### Using plugins (recommended)

`varlock` provides official plugins for popular secret management platforms, offering a seamless and type-safe way to fetch secrets directly in your `.env` files.

Available plugins include:
- [1Password](/plugins/1password/)
- [AWS Secrets Manager & Parameter Store](/plugins/aws-secrets/)
- [Azure Key Vault](/plugins/azure-key-vault/)
- [Bitwarden](/plugins/bitwarden/)
- [Google Secret Manager](/plugins/google-secret-manager/)
- [Infisical](/plugins/infisical/)

See the [plugins overview](/plugins/overview/) for the complete list.

Plugins are able to register new decorators and resolver functions that declaratively fetch secrets:

```env-spec
# Install and initialize the 1Password plugin
# @plugin(@varlock/1password-plugin)
# @initOp(token=$OP_TOKEN, allowAppAuth=forEnv(dev))
# ---

# Load secrets using the op() resolver function
# @sensitive @required
MY_SECRET=op(op://my-vault/item-name/field-name)
```

Benefits of using plugins:
- Declarative secret references safe to check into version control
- Built-in validation and type safety applied to fetched values
- Built-in authentication handling
- Better error messages and debugging
- Platform-specific features (e.g., biometric unlock for 1Password)

See each plugin's documentation for detailed setup instructions.

### Using exec() as a fallback

For cases where a plugin doesn't exist or you need custom logic, `varlock` supports fetching secrets via CLI commands using `exec()` function syntax.

```env-spec
# A secret fetched via CLI
# @sensitive @required
MY_SECRET=exec(`op read "op://devTest/myVault/credential"`);
```

This approach works with any CLI tool, ensuring no secrets are left in plaintext on your system, even if they are gitignored.

### Bulk injection with `@setValuesBulk()`

For some secret management platforms, you may already be setting key names that match your environment variable names - in which case, wiring up each value can feel like a lot of boilerplate.

In case like this, you can set many values at once using the [`@setValuesBulk()`](/reference/root-decorators/#setvaluesbulk) root decorator.

For example, using 1Password, you could store a .env style blob within a text field, or you could fetch values from their new environments tool.

```env-spec title=".env.schema"
# fetch a dotenv style blob within a text field
# @setValuesBulk(op("op://vault/field/item"))
#
# load values in a 1Password environment
# @setValuesBulk(opLoadEnvironment(your-environment-id), createMissing=true)
#
# load all secrets from an Infisical project environment
# @setValuesBulk(infisicalBulk())
#
# load Infisical secrets filtered by path or tag
# @setValuesBulk(infisicalBulk(path="/database", tag="backend"))
#
# Fetch all secrets from HashiCorp Vault as JSON
# @setValuesBulk(exec("vault kv get -format=json secret/myapp"), format=json)
# ---
```

The bulk values are injected at the precedence level of the file containing the decorator â€” so `.env.local` and `process.env` will still override them as expected. See the [reference docs](/reference/root-decorators/#setvaluesbulk) for full details.

## Security enhancements
Unlike other tools where you have to rely on pattern matching to detect _sensitive-looking_ data, `varlock` knows exactly which values are sensitive, and can take extra precautions to protect them.

For example, some of the features supported by our libraries and integrations:
- Redact sensitive values from logs
- Scan client-facing bundled code at build time
- Scan outgoing HTTP responses at runtime
{/* - Scan outgoing HTTP requests to ensure API keys are sent to the right destination only */}
{/* - Pre-commit git hooks to keep sensitive values out of version control */}

