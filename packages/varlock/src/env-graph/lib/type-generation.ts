import fs from 'node:fs';
import _ from '@env-spec/utils/my-dash';
import { EnvGraph } from './env-graph';
import { ConfigItem } from './config-item';


const AUTOGENERATED_FILE_BANNER = `
// ðŸ›‘ ðŸ›‘ ðŸ›‘ ðŸ›‘ ðŸ›‘ ðŸ›‘ ðŸ›‘ ðŸ›‘ ðŸ›‘ ðŸ›‘ ðŸ›‘ ðŸ›‘ ðŸ›‘ ðŸ›‘ ðŸ›‘ ðŸ›‘ ðŸ›‘ ðŸ›‘ ðŸ›‘ ðŸ›‘ ðŸ›‘ ðŸ›‘
// ðŸ›‘ THIS IS AN AUTOGENERATED FILE - DO NOT EDIT DIRECTLY ðŸ›‘
// ðŸ›‘ ðŸ›‘ ðŸ›‘ ðŸ›‘ ðŸ›‘ ðŸ›‘ ðŸ›‘ ðŸ›‘ ðŸ›‘ ðŸ›‘ ðŸ›‘ ðŸ›‘ ðŸ›‘ ðŸ›‘ ðŸ›‘ ðŸ›‘ ðŸ›‘ ðŸ›‘ ðŸ›‘ ðŸ›‘ ðŸ›‘ ðŸ›‘
`;


const ICON_SIZE = 20;

let iconCacheFolderInit = false;
const iconInMemoryCache: Record<string, string> = {};

async function fetchIconSvg(
  iconifyName: string,
  color = '808080', // neutral gray that should appear on black or white bg
  iconCacheFolder = '/tmp/varlock-icon-cache', // TODO: maybe move icon cache to ~/.varlock dir?
) {
  // some notes about icons
  // - using a URL that points to an svg doesn't work (but png/jpg do work)
  // - but embedding data url with an svg works fine
  // - we are fetching them on demand and caching them
  // - and then applying a color if one is set or falling back to a neutral gray that should show up on either black or white

  if (!iconCacheFolderInit) {
    fs.mkdirSync(iconCacheFolder, { recursive: true });
    iconCacheFolderInit = true;
  }

  const iconPath = `${iconCacheFolder}/${iconifyName}-${ICON_SIZE}.svg`;

  let svgSrc: string | undefined;
  if (iconInMemoryCache[iconPath]) {
    svgSrc = iconInMemoryCache[iconPath];
  } else if (fs.existsSync(iconPath)) {
    const svgFileBuffer = await fs.promises.readFile(iconPath, 'utf-8');
    svgSrc = svgFileBuffer.toString();
    iconInMemoryCache[iconPath] = svgSrc;
  } else {
    try {
      const iconSvg = await fetch(`https://api.iconify.design/${iconifyName.replace(':', '/')}.svg?height=${ICON_SIZE}`);
      svgSrc = await iconSvg.text();
    } catch (err) {
      return;
    }
    if (!svgSrc) return;


    // TODO: optionally re-enable svgo - but only as a peer dependency?
    // // run it through svgo to try to shrink it down a little
    // const optimizedSvgResult = optimize(svgSrc, {
    //   multipass: true,
    // });
    // if (!optimizedSvgResult.data) throw new Error(`Failed to optimize SVG icon - ${iconifyName}`);
    // svgSrc = optimizedSvgResult.data as string;

    if (svgSrc) {
      await fs.promises.writeFile(iconPath, svgSrc, 'utf-8');
      iconInMemoryCache[iconPath] = svgSrc;
    }
  }


  const hexColor = color.startsWith('#') ? color : `#${color}`;
  const colorizedSvg = svgSrc.replaceAll('currentColor', hexColor);
  return colorizedSvg;
}


export async function getTsDefinitionForItem(item: ConfigItem, indentLevel = 0) {
  const i = _.times(indentLevel, () => '  ').join('');
  const itemSrc = [];

  // TODO - we are assuming here that the config has been fully resolved
  // meaning if we had settings varying based on values (ex: something is required only for prod) then this wouldn't work
  // so we'll need to add a concept of fully resolving the config and triggering that first
  // also begs the question of what the types look like when the schema can vary like that...

  // TODO: also will need to figure out how we deal with null values
  // since we might need something like `key: string | null` rather than `key?: string`

  const jsDocLines = [];

  jsDocLines.push(`**${item.key}**${item.isSensitive ? ' ðŸ” _sensitive_' : ''}`);

  if (item.description) jsDocLines.push(...item.description.split('\n'));
  // type-description?

  const iconName = item.icon;
  if (iconName) {
    // TODO: pass through custom icon color? (already exists on fetchIconSvg)
    const iconSvg = await fetchIconSvg(iconName);
    if (iconSvg) jsDocLines.push(`![icon](data:image/svg+xml;utf-8,${encodeURIComponent(iconSvg)}) `);
  }

  const docsLinks = item.docsLinks;
  if (docsLinks.length) {
    jsDocLines.push('');
    docsLinks.forEach((docsEntry) => {
      // see https://jsdoc.app/tags-see for format info
      const docsLink = _.compact([docsEntry.url, docsEntry.description]).join(' | ');
      jsDocLines.push(`ðŸ“š {@link ${docsLink}}`);
    });
  }

  // more ideas:
  // - we have an `exampleValue` property we could include
  // - there's also a `@example` jsdoc directive which is meant to show a code example
  // - could add info about the original source of an item if it has been picked / imported
  // - could include additional text about type settings / validations

  if (jsDocLines.length === 1) {
    itemSrc.push(`/** ${jsDocLines[0]} */`);
  } else if (jsDocLines.length > 1) {
    itemSrc.push(...[
      '/**',
      // extra 2 trailing spaces are needed to make line breaks visible
      ..._.flatMap(jsDocLines, (line) => [` * ${line}  `]),
      ' */',
    ]);
  }

  // TODO: logic should probably be within the Item class(es) and we still need to figure out how to identify these types...
  const dataType = item.dataType;
  const dataTypeName = dataType?.name;

  let itemTsType = 'string';
  if (dataType) {
    if (dataTypeName === 'number' || dataTypeName === 'port') {
      itemTsType = 'number';
    } else if (dataTypeName === 'boolean') {
      itemTsType = 'boolean';
    } else if (dataTypeName === 'simple-object') {
      itemTsType = 'Record<string, any>';
    } else if (dataTypeName === 'enum') {
      // enums have several different formats we need to handle
      const rawEnumOptions = (dataType._rawDef as any)._rawEnumOptions;
      let enumOptions = [] as Array<any>;
      enumOptions = rawEnumOptions;

      // TODO: we'll likely add other formats later where enum options can have attached descriptions

      if (!enumOptions.length) {
        itemTsType = 'never'; // should it be any instead?
      } else {
        // we could spit out descriptions in comments here, although currently it does nothing
        // see https://github.com/microsoft/TypeScript/issues/38106
        itemTsType = _.map(enumOptions, JSON.stringify).join(' | ');
      }
    }
    // TODO: eventually handle objects, arrays, dictionaries
  }

  const isRequired = item.isRequired && !item.isRequiredDynamic;
  itemSrc.push(`${item.key}${isRequired ? '' : '?'}: ${itemTsType};`);
  itemSrc.push('');
  return _.map(itemSrc, (line) => `${i}${line}`);
}

export async function generateTsTypesSrc(graph: EnvGraph) {
  // TODO: first check if schema is valid - we dont care if values are invalid

  const tsSrc = [
    AUTOGENERATED_FILE_BANNER,
    // might want to add some options to let users inject this, or somehow detect eslint, but fine for now
    '/* eslint-disable */',
    'export type CoercedEnvSchema = {',
  ];

  const exposedKeys: Array<string> = [];
  const exposedNonSensitiveKeys: Array<string> = [];
  for (const itemKey in graph.configSchema) {
    const configItem = graph.configSchema[itemKey];
    // generate the TS type for the item in the full schema
    tsSrc.push(...await getTsDefinitionForItem(configItem, 1));

    // TODO: we will want the ability to keep some items internal and not exposed in the schema
    exposedKeys.push(itemKey);
    if (!configItem.isSensitive) exposedNonSensitiveKeys.push(itemKey);
  }

  tsSrc.push('};\n');

  tsSrc.push(`
declare module 'varlock/env' {
  export interface TypedEnvSchema extends Readonly<CoercedEnvSchema> {}
  export interface PublicTypedEnvSchema extends Readonly<Pick<CoercedEnvSchema, '${exposedNonSensitiveKeys.join("' | '")}'>> {}
}
`);

  // add types for process.env too
  // remap types for process.env
  // - enums - stay string unions if all options are strings
  // - boolean -> 'true' | 'false'
  // - everything else -> string
  tsSrc.push(`
export type EnvSchemaAsStrings = {
  [Property in keyof CoercedEnvSchema]:
    CoercedEnvSchema[Property] extends string ? CoercedEnvSchema[Property]
      : (CoercedEnvSchema[Property] extends boolean ? ('true' | 'false') : string)
};
`);

  // TODO: allow user to pass in options to control this?
  // although because we add the @generateTypes decorator an init time
  // we may need our integrations to specify what settings they prefer
  const importMetaEnvTypes = true;
  const processEnvTypes = true;

  const IMPORT_META_AUGMENTATION = `
  // add types for global import.meta.env
  interface ImportMetaEnv extends EnvSchemaAsStrings {}
  interface ImportMeta {
    readonly env: ImportMetaEnv;
  }`;
  const PROCESS_ENV_AUGMENTATION = `
  // add types for global process.env
  namespace NodeJS {
    interface ProcessEnv extends EnvSchemaAsStrings {}
  }`;

  // TODO: should add an option to enable/disable
  tsSrc.push(...[
    'declare global {',
    importMetaEnvTypes && IMPORT_META_AUGMENTATION,
    processEnvTypes && PROCESS_ENV_AUGMENTATION,
    '}',
  ].filter(Boolean));

  return tsSrc.join('\n');
}

export async function generateTypes(graph: EnvGraph, lang: string, typesPath: string) {
  if (lang !== 'ts') throw new Error(`Unsupported @generateTypes lang: ${lang}`);

  const tsSrc = await generateTsTypesSrc(graph);
  await fs.promises.writeFile(typesPath, tsSrc, 'utf-8');
}
